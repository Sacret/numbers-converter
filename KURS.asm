; Курсовая работа по информатике
; Программа перевода чисел из из одной сисетмы счисления в другие. (2/10/16)

.MODEL Small
.STACK 100h
.DATA

; Сегмент данных

    String    db    20 dup (?),'$'      ; Резервируем 20 байт для строки
    StringEnd      =  $-1                  ; Указывает на символ '$'
    Number   dw 20 dup (?), '$'     ; инициализируем переменную, в которой будет храниться число

; Далее идут всевозможные сообщения, которые будут выводиться на экран
    
   Nachalo   db   0dh, 0ah, "          KURSOVAYA RABOTA - PEREVOD CHISEL IZ ODNOJ SISTEMI V DRUGUYU",13,10,"$"
   Vvod         db  13,10, "Viberete tip chisla:",13,10,13,10,"  1 - 16-chnoe",13,10,"  2 - 10-chnoe",13,10,"  3 - 2-chnoe",13,10, 13,10,"Vvedite vash vibor (bez echa), a zatem samo chislo:",13,10,13,10,"$"

    Mes_1     db    0dh, 0ah, "Chislo v 16-y  sisteme schisleniya - ", " $" 	 ; 1-ое сообщение
    Mes_2     db    0dh, 0ah, "Chislo v 10-y  sisteme schisleniya - ", " $" 	 ; 2-ое сообщение
    Mes_3     db    0dh, 0ah, "Chislo v 2-y   sisteme schisleniya - ", " $"  	 ; 3-ье сообщение

   Vihod db 0dh, 0ah,13,10, "Dlya vihoda nazhmite lyubuyu klavishu ", "$"

.CODE
; Сегмент кода

ORG 100h
;_______________________________________________________________________
Start:			; начало основной программы
        mov ax,@data	; адрес сегмента данных в регистр ax связываем регистр dx с сегментом)
        mov ds,ax	; данные через регистр ax
        mov es,ax     
;----------------------------------------------------------------------------------------------------------------------------------------------      
mov dx, 0000       	; Установить курсор в 00.00
call Kursor		; Установка курсора	
call ClearScreen	; Очистка экрана	

                        lea dx, Nachalo	; Печать одного из сообщений
		mov ah, 09h
		int 21h	

		lea dx, Vvod		; Печатаем запрос на ввод
		mov ah, 09h
		int 21h
;_______________________________________________________________________

mov ah, 08h		; без эха вводим число (1/2/3) для выбора системы счисления	
int 21h

ViborSS:		; по введенному числу узнаем выбор системы счисления
	cmp	al,'1'    		 ; если нажата клавиша '1',
 	je	Per16   	 ; то переход на метку Per16 - перевод в 16-чную систему
 	cmp	al,'2'		 ; если клавиша '2' не нажата,
 	jne	cm1       	 ; то переход на метку Сm1
 	jmp	Per10     	 ; переход на метку Per10  - перевод в 10-ную систему
cm1:    cmp	al,'3'            	 ; если не нажата клавиша ‘3’, 
	jne	cm2       	 ; то переход на метку cm2
 	jmp	Per2     	 ; переход на метку Per2 - перевод в 2-чную систему 
cm2:	jmp	ViborSS         	 ; переход на метку ViborSS - ввели недопустимое число!  
;________________________________________________________________________
; На этой метке мы вводим в программу с клавиатуры число в 10-чной системе счисления,
; а затем переводим его в остальные...

Per10:

; Распределение регистров:
; di - накопленная часть числа
; si - номер текущей позиции
; bp=10 - делитель для процедуры ввода
; ax и dx - служебные регистры (буферы)

	mov	di, 0		; Пока ничего не введено, считаем, что число 0
	mov	si, 0		; Номер позиции в числе
	mov	bp, 10		; Потом будем умножать на 10

r1:				; далее идет ввод символов
	mov	ah, 08h	; Без эха вводим число с клавиатуры		
	int	21h		; Читаем введенный символ
	cmp	al, '0'		; Если это служебный символ -> r3
	jb	r3
	cmp	al,'9'		; Если это не цифра -> r1
	ja	r1
	mov	bl, al		; Если допустимый символ - сохраним его в bl
	mov	ax, di
	mul	bp		; Умножаем на 10
		
	mov	dl, bl
	sub	dl, '0'		; Преобразуем символ в цифру
	mov	dh, 0		; DX - цифра
	add	dx,ax		; складываем содержимое регистров
	jc	r1         	; Если перенос -> переполнение
	inc	si		; инкремент si
	mov	di, dx			
	mov	dl, bl
	mov	ah, 02h	; вывод знака на консоль
	int	21h
	jmp	r1		; идем на ввод следующего символа

r3:				; в случае нажатия служебной клавиши
	cmp	si, 0		; если до этого не было введено ни одного числа	
	je	r1		; идем на r1
	cmp	al, 13		; если это Enter
	je	enter		; Нажали ввод
	cmp	al, 8		; Нажали забой (BackSpace)
	jne	r1
zab:				; если нажали забой (BackSpace)
	dec	si		; декремент si (последний элемент нужно стереть)
	mov	ax, di
	mov	dx, 0
	div	bp
	mov	di, ax
	mov	dl, 8
	mov	ah, 2		; вывод на консоль
	int	21h
	mov	dl, 32
	int	21h
	mov	dl, 8
	int	21h
	jmp	r1		; стерли предыдущий символ - значит, вводим следующий

enter:				; при нажатии Enter
	mov	ah, 2h
	mov	dl, 13		; "печатаем" переход на следующую строку
	int	21h

	mov	dl, 10		; перевод строки
	int	21h
	mov	ax,di		; введенное число - в ax
	
mov Number, ax		; затем записываем его в переменную
jmp Metka			; переходим на метку, где переводим это число в другие системы счисления
;_________________________________________________________________________________________
; На этой метке мы вводим в программу с клавиатуры число в 16-чной системе счисления,
; а затем переводим его в остальные...

Per16: 

call Input16		; ввод оформлен в виде процедуры, поэтому мы её вызываем
jmp Metka		; переходим на метку, где переводим это число в другие системы счисления
;_________________________________________________________________________________________
; На этой метке мы вводим в программу с клавиатуры число в 2-чной системе счисления,
; а затем переводим его в остальные...

Per2:

	Mov si, 8		; устанавливаем счетчик, так как ставим ограничение на ввод символов
	xor bx, bx		; обнулили bx

Next:				; необходимая метка
	mov ah, 08h		; ввод без эха с клавиатуры
	int 21h

	cmp al, 13		; если нажат Enter - переходим на метку Stop (т.е. прекращаем ввод)
	je Stop
	cmp al, '0'		; если меньше нуля,
	jb Next			; символ пропускаем и идем дальше
	cmp al, '1'		; то же самое, если больше единицы - для двоичной недопустимые символы
	ja Next

	mov ah, 02		; если символ допустимый - вывод на экран
	mov dl, al		; и сохраняем код нажатой клавиши
	int 21h

	shl bx, 1		; сдвиг влево на 1
	sub dl, '0'		; получаем из кода цифру (отнимаем код нуля)
	xor dh, dh		; обнуляем dh
; сложение двух целочисленных двоичных операндов
; bx и dx, результат сохраняем в bx
	add bx, dx		
	dec si			; уменьшаем счетчик
	test si, si		; проверка на равенство нулю (нельзя ввести символов больше, чем разрешено)
	jnz Next		; если не ноль - вводим следующий символ

Stop:				; в том случае, если нажали Enter - прекращаем ввод
	mov al, 10		; перевод строки
	int 29h
	mov Number, bx	; сохраняем в переменную введенное 2-чное число
;_____________________________________________________________________________________________
	
Metka:			; реализуем алгоритм перевода чисел

; перевод в 16-ную систему

		lea dx, Mes_1            ; выводим на экран 1-ое сообщение
        		mov ah, 09h
       		int 21h

       		mov ax, Number       ; записываем в ax число
        		mov  bx, 16	          ; в bx - основание системы счисления (делитель)
        		std		          ; Устанавливаем обратный порядок записи
        		lea di,StringEnd-6     ; печать начинаем с 6-го с конца символа (ES:DI - 6 с конца символ строки)
        		call    Perevod_num  ; вызываем процедуру перевода   	
        		mov ah, 09h
        		lea dx, String	          ; печать полученного ответа
        		int 21h    

; перевод в 10-ную систему

	lea dx, Mes_2		; выводим на экран 2-ое сообщение
        	mov ah, 09h
        	int 21h

        	mov ax ,Number	; в ax помещаем число
        	mov  bx, 10		; записываем основание системы счисления
	std
        	lea di, StringEnd-6      ; печать начинаем с 6-го с конца символа
        	call    Perevod_num	; вызываем процедуру
        	mov ah, 09h
        	lea dx, String		; печать строки ответа
        	int 21h      

; перевод в 2-ную систему
			
 		lea dx,Mes_3		; печатаем 3-ье сообщение
        		mov ah,09h
        		int 21h

        		mov ax,Number	; в ax - число
        		mov  bx,2		; в bx - основание системы счисления
		std
        		lea di,StringEnd-6       ; печать начинаем с 6-го с конца символа
        		call    Perevod_num	; вызов процедуры
        		mov ah,09h
        		lea dx,String		; печатаем ответ
        		int 21h	
       	    	
;---------------------------------Окончание основной программы---------------------------------------
                                 ;ожидать нажатия любой клавиши
 lea dx, Vihod
 mov  ah, 09h
 int 21h	
        mov ah,8
        int 21h
; стандартный выход из программы - в данном случае при нажатии любой клавиши
	mov ah, 4ch
	int 21h
        ret
;------------------------------------- Процедура - перевод числа ---------------------------------------------------
Perevod_num proc		; объявление процедуры
        push    dx		; поднимаем в стек
        push    di
        push    cx 
        xor cx, cx			; обнуляем cx

Proverka_num:		; процедура проверки
        xor dx,dx 		; обнуляем dx
        div bx			; делим на основание системы счисления
        xchg    ax,dx		; обмен ax и dx (нас интересует остаток)
        add al,'0'			; прибавляем код нуля (получаем символ цифры)
        cmp al,'9' 		; сравнение с символом 9
        jbe  Cifra 			; если меньше либо равно - переход на Cifra (то есть записываем его)
        add al,'A'-('9'+1)		; в противном случае - число заменяем буквой (16-ричная система)
        
Cifra:				; если это цифра:
        stosb			; записываем ее в строку
        xchg    ax,dx		; обмен и ax dx
        inc cx			; инкремент cx
        test  ax, ax 		; проверка
        jne Proverka_num	; если неравны - переход на Proverka_num
        
        pop cx   			; опускаем из стека
        pop di
        pop dx
        ret
Perevod_num endp		; окончание процедуры
;_____________________________________________________________________________
;              Процедура очистики экрана:

ClearScreen  PROC   NEAR
        MOV    AX, 0600H             ; Функция прокрутки экрана
        MOV    BH, 30           	 ; Цвет (07 для ч/б)
        MOV    CX, 0000       	 ; От 00,00
        MOV    DX,184FH        	 ; До 24,79
        INT    10H            	 ; Вызов BIOS
        RET
ClearScreen endp
;______________________________________________________________________________
;              Процедура установки курсора (строка/столбец):

Kursor PROC   NEAR               ; DX уже установлен - в начале программы
        MOV    AH, 02            	; Функция установки курсора
        MOV    BH, 00          	; Страница #0
        INT    10H             	; Вызов BIOS
        RET
Kursor ENDP
;______________________________________________________________________________
; Процедура ввода с клавиатуры 16-чного числа

 Input16   proc    near

        push    cx
        push    dx
			; Будем накапливать число в CX.
        xor     cx, cx
			; Введём очередную цифру, одновременно показав её на экране.
@ih0:   
	mov     ah, 01h	; ввод с консоли - с эхом
      	int     21h

; Теперь надо преобразовать её в число. Надо отобразить
; '0'..'9' (30h..39h) в 0..9, 'A'..'F' (41h..46h) и
; 'a'..'f' (61h..66h) в 10..15, а всё остальное забраковать.
; '0'..'9', 'A'..'F', 'a'..'f' => 0..9, 11h..16h, 31h..36h

        sub     al, 30h

; Пользуясь тем, что sub устанавливает флаги так же, как cmp,
; прекращаем ввод, если символ оказался до '0' в таблице ASCII.
; Сюда же, кстати, попадает случай нажатия enter (0Dh).

        jb      short @ih3

; Теперь смотрим, если это цифра (0..9), то мы её получили. Можно
; добавлять её к числу.

        cmp     al, 09h
        jbe     short @ih2

; Если же нет, то переводим 11h..16h, 31h..36h в 0..5, 20h..25h.

        sub     al, 11h

; Если исходный символ был между '9' и 'A', прекращаем ввод.

        jb      short @ih3

; Если он попал в 'A'..'F', перешедший в 0..5, то, чтобы получить
; введённую шестнадцатеричную цифру, осталось прибавить к DL десять.

        cmp     al, 5
        jbe     short @ih1

; Если до сих пор вводим, то переводим 20h..25h в 0..5.
; Если выскочили за ноль, то введённый символ нужно забраковать.

        sub     al, 20h
        jb      short @ih3

; Если получили нечто слишком большое, тоже сдаёмся.

        cmp     al, 5
        ja      short @ih3

; Иначе исходный символ попал в 'a'..'f', отобразился в 0..5, и теперь,
; если мы прибавим к этому десять, получим введённую шестнадцатеричную цифру.

@ih1:   

	add     al, 10		; получаем цифру

; Итак, в AL очередная цифра. Надо приписать её справа к
; уже имеющемуся в CL числу. Для этого сдвигаем CL на один шестнадцатеричный
; разряд, и заполняем его введённой шестнадцатеричной цифрой.

@ih2:   
	shl     cx, 4		; сдвигаем влево на один 16-ный разряд
            or      cl, al

; Повторяем, пока не надоест вводить нечто шестнадцатеричное.

        jmp     short @ih0	; то есть воод следующей цифры

; Сюда мы попадём, когда введут нецифру. Здесь перейдём на новую строку
@ih3:   
        mov     ah, 02h 	; выводим эту "нецифру" на консоль, чтоб пользователь понял, что ошибся, и мы прекратили ввод
        mov     dl, 0Dh	; "нажимаем" Enter
        int     21h

        mov     dl, 0Ah	; перевод строки
        int     21h

mov Number, cx	; результат поместили в нашу переменную

        mov     ax, cx	; и запишем результат в AX.
        pop     dx
        pop     cx
        ret
Input16   endp		; конец процедуры

end Start		; конец основной программы
